#!/usr/bin/env python3

"""jemdoc version 0.7.3, 2012-11-27."""

# Copyright (C) 2007-2012 Jacob Mattingley (jacobm@stanford.edu).
#
# This file is part of jemdoc.
#
# jemdoc is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# jemdoc is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
#
# The LaTeX equation portions of this file were initially based on
# latexmath2png, by Kamil Kisiel (kamil@kamikisiel.net).
#

import sys
import os
import re
import time
import io

def version():
  print(__doc__)
  print('Platform:', sys.platform)
  print('Python:', sys.version[:5], 'located at', sys.executable)
  print('Equation support:', 'mathjax')
  print('Markdown support:', 'markdown')

def showhelp():
  a = """Usage: jemdoc [OPTIONS] [SOURCEFILE]
  Produces html markup from a jemdoc SOURCEFILE.

  Most of the time you can use jemdoc without any additional flags.
  For example, typing

    jemdoc index

  will produce an index.html from index.jemdoc, using a default
  configuration.

  Some configuration options can be overridden by specifying a
  configuration file.  You can use

    jemdoc --show-config

  to print a sample configuration file (which includes all of the
  default options). Any or all of the configuration [blocks] can be
  overwritten by including them in a configuration file, and running,
  for example,

    jemdoc -c mywebsite.conf index.jemdoc

  You can view version and installation details with

    jemdoc --version

  See http://jemdoc.jaboc.net/ for many more details."""
  print(a.replace("\n  ", "\n").strip())

def printStandardConfig():
  for i in standardconf().items():
      print("[%s]%s" % i)

def standardconf():
  import collections
  a = collections.defaultdict(lambda: ("", ""))
  a["html"] = """
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  ""","""
  </html>
  """
  
  a["head"] ="""
  <head>
  <meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  ""","""
  </head>
  """

  a["body"] = """
  <body>
  """, """
  </body>
  """

  # used in header for window title.
  a["title"] = """
  <title>
  ""","""
  </title>
  """

  a["header"] = """
  <header>
  """, """
  </header>
  """

  a["footer"] = """
  <footer>
  """, """
  </footer>
  """

  a["mathjax"] = """
  <!-- MathJax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  	  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>
  <!-- End MathJax -->
  """, ""

  a["lastupdated"] = """
  Page generated ""","""
  by <a href="https://github.com/wsshin/jemdoc_mathjax" target="blank">jemdoc+MathJax</a>.
  """

  return a

def parseconf(cns):
  syntax = standardconf()
  
  for sname in cns:
      with io.open(sname, 'rb') as f:
        while pc(controlstruct(f)) != '':
          l = readnoncomment(f)
          r = re.match(r'\[(.*)\]\n', l)

          if r:
            tag = r.group(1)

            s = ''
            l = readnoncomment(f)
            while l not in ('\n', ''):
              s += l
              l = readnoncomment(f)

            syntax[tag] = s

  return syntax

def insertmenuitems(f, mname, current, prefix):
  m = io.open(mname, 'rb')
  while pc(controlstruct(m)) != '':
    l = readnoncomment(m)
    l = l.strip()
    if l == '':
      continue

    r = re.match(r'\s*(.*?)\s*\[(.*)\]', l)

    if r: # then we have a menu item.
      link = r.group(2)
      if link[0] == '\\':
        option = ' target="blank"'
        link = link[1:]
      else:
        option = ''

      # Don't use prefix if we have an absolute link.
      if '://' not in r.group(2):
        link = prefix + allreplace(link)

      # replace spaces with nbsps.
      # do do this, even though css would make it work - ie ignores.
      # only replace spaces that aren't in {{ blocks.
      in_quote = False
      menuitem = ""
      for group in re.split(r'({{|}})', r.group(1)):
        if in_quote:
          if group == '}}':
            in_quote = False
            next
          else:
            menuitem += group
        else:
          if group == '{{':
            in_quote = True
            next
          else:
            menuitem += br(re.sub(r'(?<!\\n) +', '~', group), f)

      if link[-len(current):] == current:
        hb(f.outf, f.conf['currentmenuitem'], link, menuitem, option)
      else:
        hb(f.outf, f.conf['menuitem'], link, menuitem, option)

    else: # menu category.
      hb(f.outf, f.conf['menucategory'], br(l, f))

  m.close()

def out(f, s):
    f.write(s)

def mathjaxussub(link):
  return link.replace('_', 'UNDERSCORE65358')

def mathjaxusresub(r):
  return re.sub('UNDERSCORE65358', '_', r)

def mathjaxeqsub(eqtext):
  eqtext = eqtext.replace('\\', 'BACKSLASH65358')
  eqtext = eqtext.replace('[', 'OPENBRACKET65358')
  eqtext = eqtext.replace(']', 'CLOSEBRACKET65358')
  eqtext = eqtext.replace('*', 'ASTERISK65358')
  eqtext = eqtext.replace('+', 'PLUS65358')
  eqtext = eqtext.replace('&', 'AMPERSAND65358')
  eqtext = eqtext.replace('<', 'LESSTHAN65358')
  eqtext = eqtext.replace('>', 'GREATERTHAN65358')
#  eqtext = eqtext.replace('\n', ' ')
  eqtext = eqtext.replace('_', 'UNDERSCORE65358')
  eqtext = eqtext.replace('/', 'SLASH65358')

  return eqtext

def mathjaxeqresub(r):
  r = re.sub('BACKSLASH65358', r'\\', r)
  r = re.sub('OPENBRACKET65358', '[', r)
  r = re.sub('CLOSEBRACKET65358', ']', r)
  r = re.sub('ASTERISK65358', '*', r)
  r = re.sub('PLUS65358', '+', r)
  r = re.sub('AMPERSAND65358', '&', r)
  r = re.sub('LESSTHAN65358', '<', r)
  r = re.sub('GREATERTHAN65358', '>', r)
  r = re.sub('QUOTATION65358', '"', r)
  r = re.sub('UNDERSCORE65358', '_', r)
  r = re.sub('SLASH65358', '/', r)

  return r

def hb(f, tag, content1, content2=None, content3=None):
  """Writes out a halfblock (hb)."""

  if content1 is None:
    content1 = ""

  if content3 is None:
    content3 = ""

  if content2 is None:
#    out(f, re.sub(r'\|', content1, tag))
    r = re.sub(r'\|', content1, tag)
    r = re.sub(r'\|3', content3, r)
    r = mathjaxeqresub(r)
    out(f, r)
  else:
    r = re.sub(r'\|1', content1, tag)
    r = re.sub(r'\|3', content3, r)
    r = re.sub(r'\|2', content2, r)
    r = mathjaxeqresub(r)
    out(f, r)

def pc(f, ditchcomments=True):
  """Peeks at next character in the file."""
  # Should only be used to look at the first character of a new line.
  c = f.inf.read(1).decode('cp1252')
  if c: # only undo forward movement if we're not at the end.
    if ditchcomments and c == '#':
      l = nl(f)
      if doincludes(f, l):
        return "#"

    if c in ' \t':
      return pc(f)

    if c == '\\':
      c += pc(f)

    f.inf.seek(-1, 1)
  elif f.otherfiles:
    f.nextfile()
    return pc(f, ditchcomments)

  return c

def doincludes(f, l):
  ir = 'includeraw{'
  i = 'include{'
  if l.startswith(ir):
    nf = io.open(l[len(ir):-2], 'rb')
    f.outf.write(nf.read())
    nf.close()
  elif l.startswith(i):
    f.pushfile(l[len(i):-2])
  else:
    return False

  return True

def nl(f, withcount=False, codemode=False):
  """Get input file line."""
  s = f.inf.readline().decode('utf-8')
  if not s and f.otherfiles:
    f.nextfile()
    return nl(f, withcount, codemode)

  f.linenum += 1

  if not codemode:
    # remove any special characters - assume they were checked by pc()
    # before we got here.
    # remove any trailing comments.
    s = s.lstrip(' \t')
    s = re.sub(r'\s*(?<!\\)#.*', '', s)

  if withcount:
    if s[0] == '.':
      m = r'\.'
    else:
      m = s[0]

    r = re.match('(%s+) ' % m, s)
    if not r:
      raise SyntaxError("couldn't handle the jandal (code 12039) on line"
                " %d" % f.linenum)

    if not codemode:
      s = s.lstrip('-.=:')

    return (s, len(r.group(1)))
  else:
    if not codemode:
      s = s.lstrip('-.=:')

    return s

def np(f, withcount=False, eatblanks=True):
  """Gets the next paragraph from the input file."""
  # New paragraph markers signalled by characters in following tuple.
  if withcount:
    (s, c) = nl(f, withcount)
  else:
    s = nl(f)

  # Determine if the current line has an open inline equation block or not.
  r = re.compile(r'(?<!\\)\$')
  m = r.findall(s)
  lm = len(m) % 2
  isopeneq = lm == 1

  # The followings characters signal a new paragraph when appeared right after '\n'.
  # The original list included '-', which should not signal a new paragraph when used as the first character of a matrix row inside inline equation blocks.  Therefore, '-' is handled separately.
  nl_signals = ('\n', '.', ':', '', '=', '~', '{', '\\(', '\\)')

  pcf = pc(f)
  while (not isopeneq and pcf != '-' and pcf not in nl_signals) or (isopeneq and pcf not in nl_signals):
    if isopeneq and pcf == '-':
      s += '-'
    ns = nl(f)
    m = r.findall(ns)
    lm = (lm + len(m)) % 2
    isopeneq = lm == 1
    s += ns
    pcf = pc(f)

  while eatblanks and pc(f) == '\n':
    nl(f) # burn blank line.

  # in both cases, ditch the trailing \n.
  if withcount:
    return (s[:-1], c)
  else:
    return s[:-1]

def quote(s):
  return re.sub(r"""[\\*/+"'<>&$%\.~[\]-]""", r'\\\g<0>', s)

def replacequoted(b):
  """Quotes {{raw html}} sections."""

  r = re.compile(r'\{\{(.*?)\}\}', re.M + re.S)
  m = r.search(b)
  while m:
    qb = quote(m.group(1))

    b = b[:m.start()] + qb + b[m.end():]

    m = r.search(b, m.start())

  return b

def replacepercents(b):
  # replace %sections% as +{{sections}}+. Do not replace if within a link.

  r = re.compile(r'(?<!\\)%(.*?)(?<!\\)%', re.M + re.S)
  m = r.search(b)
  while m:
    #qb = '+' + quote(m.group(1)) + '+'
    a = re.sub(r'\[', r'BSNOTLINKLEFT12039XX', m.group(1))
    a = re.sub(r'\]', r'BSNOTLINKRIGHT12039XX', a)
    qb = '+{{' + a + '}}+'

    b = b[:m.start()] + qb + b[m.end():]

    m = r.search(b, m.start())

  return b

def replaceequations(b, f):
  # replace $sections$ and \(sections\) as equations.
  rs = ((re.compile(r'(?<!\\)\$(.*?)(?<!\\)\$', re.M + re.S), False),
     (re.compile(r'(?<!\\)\\\((.*?)(?<!\\)\\\)', re.M + re.S), True))
  for (r, wl) in rs:
    m = r.search(b)
    while m:
      eq = m.group(1)
      if wl:
        fn = str(abs(hash(eq + 'wl120930alsdk')))
      else:
        fn = str(abs(hash(eq)))

      eqtext = allreplace(eq)
      eqtext = mathjaxeqsub(eqtext)

      # Double braces will cause problems with escaping of image tag.
      eqtext = eqtext.replace('{{', 'DOUBLEOPENBRACE')
      eqtext = eqtext.replace('}}', 'DOUBLECLOSEBRACE')

      if wl:
        b = b[:m.start()] + 'BACKSLASH65358OPENBRACKET65358' + eqtext + 'BACKSLASH65358CLOSEBRACKET65358'+ b[m.end():]
        b = '<p style=QUOTATION65358text-align:centerQUOTATION65358>\n' + b + '\n</p>'
        b = mathjaxeqsub(b)
      else:
        b = b[:m.start()] + 'BACKSLASH65358(' + eqtext + 'BACKSLASH65358)' + b[m.end():]

      # jem: also clean out line breaks in the alttext?
      m = r.search(b, m.start())

  return replacequoted(b)

def parse_meta(line):
    if not line.startswith("<njnmdoc "):
        return defaultdict(), False

    # https://stackoverflow.com/a/38305337/986793
    m = re.compile(r"""((?:(?!\s|=).)*)\s*?=\s*?["']?((?:(?<=")(?:(?<=\\)"|[^"])*|(?<=')(?:(?<=\\)'|[^'])*)|(?:(?!"|')(?:(?!\/>|>|\s).)+))""")

    meta = dict(m.findall(line))

    meta['lastupdated'] = time.strftime( '%Y-%m-%d', time.localtime(time.time()))

    return meta, True


def Rndr(block, *args):
    return "".join([block[0], *args, block[1]])

# this is the main template
def template(config, meta, content):
    a = config
    return  \
    Rndr(a["html"],
            Rndr(a["head"],
                Rndr(a['mathjax']),
                Rndr(a["title"], meta['title'])),
            Rndr(a["body"],
                Rndr(a["header"], meta['title']),
                Rndr(a["nav"], meta['menu']),
                Rndr(a["content"], *content),
                Rndr(a["footer"],
                    Rndr(a['lastupdated'], meta['lastupdated']))
                )
            )



def build(infile, outfile, config):
    a = config

    with open(infile, 'r') as input:
        meta = input.readline()
        content = input.readlines()

    meta, valid = parse_meta(meta)
    if not valid:
        content.insert(0, meta)

    html = template(config, meta, content)

    with open(outfile, 'w') as out:
        out.write(html)


def main():
  if len(sys.argv) == 1 or sys.argv[1] in ('--help', '-h'):
    showhelp()
    raise SystemExit
  if sys.argv[1] == '--show-config':
    printStandardConfig()
    raise SystemExit
  if sys.argv[1] == '--version':
    version()
    raise SystemExit

  outname = None
  confnames = []
  for i in range(1, len(sys.argv), 2):
    if sys.argv[i] == '-o':
      if outname is not None:
        raise RuntimeError("only one output file / directory, please")
      outname = sys.argv[i+1]
    elif sys.argv[i] == '-c':
      confnames.append(sys.argv[i+1])
    elif sys.argv[i].startswith('-'):
      raise RuntimeError('unrecognised argument %s, try --help' % sys.argv[i])
    else:
      break

  conf = parseconf(confnames)

  innames = []
  for inname in sys.argv[i:]:
    # First, if not a file and no dot, try opening .jemdoc. Otherwise, fall back
    # to just doing exactly as asked.
    if not os.path.isfile(inname):
        if os.path.isfile(inname + ".jemdoc"):
          inname += '.jemdoc'
        else:
          raise RuntimeError('unrecognised file %s' % sys.argv[i])

    innames.append(inname)

  if outname is not None and not os.path.isdir(outname) and len(innames) > 1:
    raise RuntimeError('cannot handle one outfile with multiple infiles')

  for inname in innames:
    if outname is None:
      thisout = re.sub(r'.jemdoc$', '', inname) + '.html'
    elif os.path.isdir(outname):
      # if directory, prepend directory to automatically generated name.
      thisout = outname + re.sub(r'.jemdoc$', '', inname) + '.html'
    else:
      thisout = outname

    build(inname, thisout, conf)


if __name__ == '__main__':
  main()
